<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Type &amp; dynamics typing</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="52561aee-854b-46e5-9225-e4862a1b72bd" class="page sans"><header><h1 class="page-title">Type &amp; dynamics typing</h1></header><div class="page-body"><nav id="a8a28731-74c7-44a0-8625-0154150a637b" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#aaf50980-6394-47f3-98da-2d5012c3d501">1 - The type Type</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bafe524b-942c-4269-a26c-9bec879c7e8b">2 - typeof first way to dynamic type</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#bf461562-6cd6-4ffd-b722-51437e2f7e32">3 - adapte the type automatically !</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#10903db0-d12b-4e91-9382-28a698870551">4 - any type, the real dynamic type</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#16d8ed48-94fd-4ac6-9fae-f26134fb3527">5 - How to use a dynamic type ?</a></div></nav><h1 id="aaf50980-6394-47f3-98da-2d5012c3d501" class="">1 - The type Type</h1><p id="4a341363-e02b-4b5b-8c7f-3e3fd9675d63" class=""><em>what is the type Type, how to get it (without typeof) and what can we get from it (w/o typeof)</em></p><p id="cf7cd2c1-873b-4a9a-84f4-d2e531191063" class="">Type is a special type of Nu. It represents the types in Nu... It is not possible to build a new value of type Type, we can only get existing one. Actually, to &quot;create&quot; a new Type value, we just need to create a new type. And to use it, we simply use the type name.</p><p id="c5721338-65bc-467d-8516-6f7d26ffd613" class=""> </p><pre id="49089c36-ea05-4e08-ab60-7d2b1001c143" class="code code-wrap"><code>package Pkg1

import Std io.console as cio

struct type A = {
	val int
	get val2 int
	internal val3 int
}
struct implem A = {
	val4 int
}

func DisplayType(t Type) {
	cio.Println(t)
}

//another file
package main

import {
	Pkg1
	Std io.console as cio
}

func DisplayType(t Type) {
	cio.Println(t)
}

func main() {
	DisplayType(int) // print: type int&lt;64&gt;
	DisplayType(Pkg1.A) // print: struct A{val int, get val2 int, internal int}
	Pkg1.DisplayType(Pkg1.A)
// print: struct A{val int, get val2 int, internal val3 int, implem val4 int}
}</code></pre><p id="63e9773a-f6dc-4020-bdc3-b8361c23f99f" class="">Here, according to the package the print is not the same !!
Because Type will have dynamic stuff.
Here are the methods/attributs of Type:

first the <em>static</em> part 

<code>.description_of(val T) string</code> : where T is the type link to the Type. This method is used with <code>Std</code> <code>io.console.Print</code> to display value. It is value representation according to the type.

<code>.description() string</code>: It is the description of the type. Used for: <em><code>Type</code></em><code>.description_of(</code><em><code>Type</code></em><code>)</code> (call when we write something like: <code>io.console.Print(int)</code>.

[<em>get] </em><code>.Name string</code> : gives the name of the type.
<em>[get]</em> <code>.Kind string</code> : gives the kind of the type (<code>struct</code>, <code>interface</code>, <code>class</code>, <code>type</code>, or <code>func</code> (and <code>enum</code> we&#x27;ll see that later)).
<code>.Attributs() [string]Type</code> : gives the attributes of the type. If the type doesn&#x27;t have any, it is just an empty dictionary. For function types, Attributs is fill for argument, and there is the <em>return</em> attribut and its corresponding <em>Type</em>. Attributs is always present but the values will be different according to the context where the Type is used (it will hide <code>implem</code> and <code>internal</code> attributes)
<code>.Methods() [string]Type</code> : gives the methods of the type. The <code>Type</code> here is always a function type. Same thing than <code>.Attributs</code>, if there is not methods, it is an empty dictionary. For function type, Methods is always empty. Same than Attributes, Methods will be different according to the context.

Then <code>Type</code> holds dynamics information automatically fill. If the type is known the dynamic incertitude is lost, but if it doesn&#x27;t, then it may <code>throw</code> an <code>Error</code> (<em><code>DynamicTypeError</code></em>).
We see in the 2nd point how to get dynamic <code>Type</code>.
</p><p id="85aa33ff-ba7d-41b9-8e86-f67e8d81a595" class=""><span style="border-bottom:0.05em solid"><em>exemple</em></span><span style="border-bottom:0.05em solid">:</span>
</p><pre id="4710c08b-6b73-4d3b-8648-ebb2653cc492" class="code"><code>package main

import {
	Std io.console as cio
}

struct type A = {
	val int
}

struct type Derived = A with {
	val2 string
}

func main() {
	cio.Println(Derived.Base) // &lt;=&gt; cio.Println(A) â†’ struct A{val int}
}</code></pre><h1 id="bafe524b-942c-4269-a26c-9bec879c7e8b" class="">2 - typeof first way to dynamic type</h1><p id="fb15bd04-adb0-408c-afdf-f72fddae8379" class=""><em>typeof(t Type) to get the actual type, typeof(variable) to get the Type, typeof(interface) to get its dynamic and static Type.</em></p><p id="e5fc4dee-5b63-45ea-93b1-13937e415c89" class="">It is possible to get the <code>Type</code> of any expression with the <code>typeof</code> Nu expression.</p><pre id="129c2a3b-c16b-4e4a-be95-74bc46f52f23" class="code code-wrap"><code>package main

func main() {
	v := 42
	vType := typeof(v) // &lt;=&gt; vType := int
}</code></pre><p id="981f22d2-2381-44d2-ab8d-3a3714653d4d" class="">But <code>typeof</code> can also be used to represent the type itself.</p><pre id="9ecd4c2a-05bf-41c2-87f7-070227c5e0a7" class="code code-wrap"><code>package main

func main() {
	v := 42
	var v2 typeof(v) // &lt;=&gt; var v2 int
}</code></pre><p id="ec0edad4-eed2-4364-a371-1abe785e6a82" class="">It is even possible to use <code>Type</code> to get a type, with <code>typeof</code> !!</p><pre id="f3db1022-d326-441f-99e5-2f96a2b511b9" class="code code-wrap"><code>package main

func main() {
	t := int // t is Type
	var val typeof(t)
}</code></pre><p id="04860b45-059c-4bb5-93f7-7517db7d72b6" class="">We understand than it is not possible to get the <code>Type</code> of <code>Type</code>, that&#x27;s why <code>typeof(Type)</code> will represent the type itself. So <code>t := int</code> and <code>t := typeof(int)</code> have the same result (but the second will be more costly because it has to analyse the <code>Type</code> before restitute it).
When using the <code>typeof(Type)</code> way to represent a type, the value will be dynamically typed (but still strongly).

Now, it is important to notice than <code>typeof(</code><em>Value</em><code>)</code> will give the <em>static</em> type of the value, but will holds the <em>dynamics</em> data of it.</p><pre id="11fb6bd3-3396-46d9-9a1c-14ddcd068f8b" class="code code-wrap"><code>package main

import Std io.console as cio

struct type A = {
	val = 42
}

struct type B = A with {
	val2 = &quot;i&#x27;m B&quot;
}

func main() {
	var static_a A = B{} as A // ok
	//cio.Println(typeof(static_a).DynamicValueData) //
	cio.Println(typeof(static_a).HasDynamicValueData) // false

	var dyn_a *A = new B{} as *A // ok
	cio.Println(typeof(dyn_a).HasDynamicValueData) // true, typeof(VAR) may holds dynamic data, here it does.

	dyn_a_type := typeof(dyn_a) // != *A; *A would only holds static info about the type *A.
	if dyn_a_type.HasAttribute(&quot;DynamicType&quot;) { // not mandatory but recommended
		dyn_a_type = dyn_a_type.DynamicType // throw if .HasAttribute is false.
	}
	var b *typeof(dyn_a_type) // here var b *B
	b -&gt; &amp;dyn_a as *typeof(b) // or as typeof(&amp;b)
}</code></pre><p id="994423fd-eddc-4163-85e2-174209205dfa" class=""><em><span style="border-bottom:0.05em solid">Remarque</span></em><em>: if possible it is always better to not use the dynamic type as it is less efficient.
</em>Here, <em>b</em> has a dynamic (strong) type because it comes from <code>typeof(</code><em><code>TYPE</code></em><code>)</code>. 
Here another example that will show why the type is dynamic (and the power of that feature):</p><pre id="270c4d88-84fc-4a4b-baf6-d66605a3ff4a" class="code code-wrap"><code>package main

import Std io.console as cio

func main() {
	var var_t Type
	if res := cio.Get&lt;string&gt;(); res == int.Name {
		var_t = int
	} else if res == string.Name {
		var_t = string
	} else if res == bool.Name {
		var_t = bool
	} else {
		cio.Println(res, &quot;is not type... :(&quot;)
		return
	}
	
	val := typeof(val_t){} // &lt;=&gt; var val typeof(val_t) = typeof(val_t){}
	_ = val // type of val is can not be known at compile time
}</code></pre><h1 id="bf461562-6cd6-4ffd-b722-51437e2f7e32" class="">3 - adapte the type automatically !</h1><p id="b311f7da-35b9-4872-8b7f-dcf41a2aa8f4" class="">With <code>typeof</code> we saw how to dynamically type a variable according to other <em>expression</em> or through the value of a <code>Type</code>.
But we may want to declare a variable that will be typed at runtime dynamically like <code>typeof</code>, but typed at first assignment !
That is the goal of the <code>auto</code> qualifier type.
A variable declare <code>auto</code> can&#x27;t be used before it has been initialised in all possible conditional branches. Juste like consts in function body. It is possible to specify if we want the type to be a pointer or an optional with: <code>*auto</code> or <code>auto?</code>.</p><pre id="3b6cf76c-b991-44b9-b79e-258dcd2abc39" class="code code-wrap"><code>package main

import Std io.console as cio

func main() {
	var a auto // we don&#x27;t know the type yet
	if res := cio.Get&lt;string&gt;(); res == int.Name then a = 42
	else if res == string.Name then a = &quot;i&#x27;m a string&quot;
	else res == bool.Name then a = true
	cio.Println(a) // ok, a is initialised
	// print weather 42, i&#x27;m a string, or true, according to the input made
}</code></pre><p id="33131c66-ba16-4ce2-a91d-07d76c7b5ee0" class="">This avoid using a <code>Type</code> variable !
This can be useful for functions which has dynamic input arguments, or return dynamic values.</p><h1 id="10903db0-d12b-4e91-9382-28a698870551" class="">4 - any type, the real dynamic type</h1><p id="e69da732-a579-44cc-8770-02b20d829af3" class="">You thought we finished talking type ? Not really. But we are close to the end with the type: <code>any</code>. Which is not really a type.
<code>any</code> allows to store every kind of type, and it allows to change dynamically the type it holds.<em>
</em>In addition of assigning value of its dynamic type, it is also possible to use the operator <code>-&gt;</code> to change a type/value.
Unlike <code>auto</code>, it is not possible to add pointer or optional to <code>any</code> because <code>any</code> is a volatile type that will certainly change. So it could represent a pointer, then an optional, then, whatever.</p><pre id="3ac034fd-84ba-4dcf-8524-5f84ebe5270b" class="code code-wrap"><code>package main

func main() {
	var v any // == nil, typeof(v) == void
	v -&gt; 42 // ok, now typeof(v) == int
	v = &quot;coucou&quot; // compile (but warning lv 5, since it may throw, (here it will))
	// &lt;=&gt; v = &quot;coucou&quot; as typeof(v)
	v -&gt; string // ok ! now typeof(v) == string
}</code></pre><h1 id="16d8ed48-94fd-4ac6-9fae-f26134fb3527" class="">5 - How to use a dynamic type ?</h1><p id="9d132f5d-e72c-48b8-990e-9790e335edd5" class="">So fare we saw how to get the <code>Type</code> and make dynamic variable with <code>typeof</code>, we saw how we could dynamically type our variable with <code>auto</code>, and we saw how we could dynamically adapte the type of a variable with <code>any</code>.
But in all the example, we never use those variables.
It is because as dynamic type, it can&#x27;t be use the same way. The compiler can&#x27;t know the type of the variable, so using them would inevitably <code>throw</code> an <code>Error</code> one day or another. It is really not safe, and it is not robust. That&#x27;s why except for the operator <code>=</code> which will &quot;just&quot; make a warning message, to use a dynamic type variable the incertitude must be solved, or the expression must be a <code>try</code> exp.
To resolve the incertitude of a dynamic type the safe and easy method is: the <em>if-is</em>. If-is allows to check if a variable is a certain type, and then inside its scope the variable is considered as the checked type (if the type is more precise than the type known in the variable). Another way to resolve the incertitude is to <em>cast</em> the variable. If a cast exists between the dynamic type and the type we want to cast in, then it will work, but else it will <code>throw</code> an <code>Error</code>.</p><pre id="2da83df8-0745-4037-8ab8-0aa8e9c76a7c" class="code code-wrap"><code>package main

import Std io.console as cio

func sum(a, b auto) auto? {
	try return a + b // ok, we use a try exp
/* what nu will do:

if typeof(a).HasOperator(&quot;+&quot;, typeof(b)) { ... }
else if typeof(b).HasOperator(typeof(a), &quot;+&quot;) { ... }
else if typeof(a).HasOperator(&quot;+&quot;) &amp;&amp; typeof(b).HasExplicitCastTo(typeof(a)) {
	try return a + b as typeof(a)
} else if typeof(b).HasOperator(&quot;+&quot;) &amp;&amp; typeof(a).HasExplicitCastTo(typeof(b)) 
	try return a as typeof(b) + b
}
*/
}

func main() {
	var dyn any = sum(18, 24) ?? nil
/* if sum is nil then any will have the value nil from void and will be typed
	void. If we don&#x27;t put the &quot;?? nil&quot; then
*/
	if dyn is int then dyn++ // her dyn is no longer considered as any but as int
	cio.Println(dyn as int + 1) // generate a warning lv 4
	// print
		
}</code></pre><p id="4073d392-564e-416c-81a2-4011c774c978" class="">The representation of <em><code>Type</code></em> for pointer in <strong>Nu</strong>, are the same than the type they point to. But there is the attribute: <code>IsPointer</code> set to <code>true</code>. And then they also have the dynamic attribute: <code>DynamicType</code> which is a <code>Type</code> corresponding to the dynamic type of the pointer (that may be the same than the current type without dynamic values).

Another useful usage of the <code>auto</code> specifier, is to make container with multiple type:
<code>var v []auto = [18, &quot;salut&quot;]; v.append(true)</code>.</p></div></article></body></html><script>
	var codes = document.getElementsByTagName('code');
	for (var i = 0; i < codes.length; i++) {
		codes.item(i).classList.add('prettyprint', 'lang-go')
	}
</script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=go;skin=desert"></script>